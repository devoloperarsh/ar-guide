<!DOCTYPE html>
<html>
<head>
  <title>AR AI Friend</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700&display=swap" rel="stylesheet">
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(135deg,#4f84ff 0%, #dca7ff 100%);
      font-family: 'Nunito', sans-serif;
    }
    /* #ui removed for single mic button only */ #ui {
      position: fixed;
      width: 100vw;
      max-width: 100vw;
      min-width: 0;
      left: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4vw;
      z-index: 7;
      background: rgba(255,255,255,0.12);
      padding-top: 4vw;
      padding-bottom: 4vw;
      box-shadow: 0 -6px 32px #2223;
      border-top-left-radius: 4vw;
      border-top-right-radius: 4vw;
    }
    #mic {
      background: linear-gradient(135deg,#36d1c4,#5b86e5);
      color: white;
      border: none;
      font-size: 7vw;
      border-radius: 50vw;
      width: 18vw;
      height: 18vw;
      max-width: 90px;
      max-height: 90px;
      min-width: 52px;
      min-height: 52px;
      box-shadow: 0 6px 32px #2edab233;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: box-shadow 0.15s, background 0.15s;
      cursor: pointer;
      outline: none;
      margin-bottom: 1vw;
      touch-action: manipulation;
    }
    #mic.recording {
      background:linear-gradient(135deg,#ea447a,#ff6c33);
      box-shadow: 0 8px 30px rgba(234,68,122,0.7);
      animation: pulse 1.2s infinite;
      transform: scale(1.05);
    }
    @keyframes pulse {
      0% { box-shadow: 0 8px 30px rgba(234,68,122,0.7), 0 0 0 0 rgba(234,68,122,0.4); }
      50% { box-shadow: 0 8px 30px rgba(234,68,122,0.7), 0 0 0 15px rgba(234,68,122,0); }
      100% { box-shadow: 0 8px 30px rgba(234,68,122,0.7), 0 0 0 0 rgba(234,68,122,0); }
    }
    #status, #ai-response {
      color: #fff;
      background:rgba(0,0,0,0.22);
      border-radius:4vw;
      padding:2vw 5vw 2vw 5vw;
      font-size:4vw;
      max-width:86vw;
      margin:auto;
      word-break: break-word;
      box-sizing: border-box;
      line-height:1.6em;
    }
    #ai-response {
      font-size:5vw;
      color:#ffe47a;
      margin-bottom:2vw;
    }
  </style>
</head>
<body>

<a-scene arjs="sourceType: webcam; detectionMode: mono_and_matrix; matrixCodeType: 3x3; cameraParametersUrl: https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/data/camera_para.dat; maxDetectionRate: 60; canvasWidth: 1280; canvasHeight: 720;" vr-mode-ui="enabled: false" renderer="logarithmicDepthBuffer: true;">
  <a-marker preset="hiro" id="ar-marker" size="1">
    <!-- Breathing animations (default idle) -->
    <a-entity id="breathing1" gltf-model="breathing1.glb" scale="0.5 0.5 0.5" rotation="0 0 0" visible="false" animation-mixer persistent-avatar></a-entity>
    <a-entity id="breathing2" gltf-model="breathing2.glb" scale="0.5 0.5 0.5" rotation="0 0 0" visible="false" animation-mixer persistent-avatar></a-entity>
    <!-- Talking animations -->
    <a-entity id="talking1" gltf-model="talking1.glb" scale="0.5 0.5 0.5" rotation="0 0 0" visible="false" animation-mixer persistent-avatar></a-entity>
    <a-entity id="talking2" gltf-model="talking2.glb" scale="0.5 0.5 0.5" rotation="0 0 0" visible="false" animation-mixer persistent-avatar></a-entity>
    <!-- Dance animations -->
    <a-entity id="dance1" gltf-model="dance1.glb" scale="0.5 0.5 0.5" rotation="0 0 0" visible="false" animation-mixer persistent-avatar></a-entity>
    <a-entity id="dance2" gltf-model="dance2.glb" scale="0.5 0.5 0.5" rotation="0 0 0" visible="false" animation-mixer persistent-avatar></a-entity>
    <a-entity id="dance3" gltf-model="dance3.glb" scale="0.5 0.5 0.5" rotation="0 0 0" visible="false" animation-mixer persistent-avatar></a-entity>
    <!-- Fight/Angry animations -->
    <a-entity id="fight1" gltf-model="fight1.glb" scale="0.5 0.5 0.5" rotation="0 0 0" visible="false" animation-mixer persistent-avatar></a-entity>
    <a-entity id="fight2" gltf-model="fight2.glb" scale="0.5 0.5 0.5" rotation="0 0 0" visible="false" animation-mixer persistent-avatar></a-entity>
    <!-- Emotion animations -->
    <a-entity id="happy" gltf-model="happy.glb" scale="0.5 0.5 0.5" rotation="0 0 0" visible="false" animation-mixer persistent-avatar></a-entity>
    <a-entity id="laughing" gltf-model="laughing.glb" scale="0.5 0.5 0.5" rotation="0 0 0" visible="false" animation-mixer persistent-avatar></a-entity>
    <a-entity id="sad" gltf-model="sad.glb" scale="0.5 0.5 0.5" rotation="0 0 0" visible="false" animation-mixer persistent-avatar></a-entity>
    <!-- Action animations -->
    <a-entity id="sitting" gltf-model="sitting.glb" scale="0.5 0.5 0.5" rotation="0 0 0" visible="false" animation-mixer persistent-avatar></a-entity>
    <a-entity id="sing" gltf-model="sing.glb" scale="0.5 0.5 0.5" rotation="0 0 0" visible="false" animation-mixer persistent-avatar></a-entity>
  </a-marker>
  <a-entity camera></a-entity>
</a-scene>

<div id="speech-overlay" style="position:fixed;z-index:15;left:50%;bottom:2vw;transform:translateX(-50%);background:rgba(0,0,0,0.75);color:#fff;padding:1vw 2.5vw;border-radius:1vw;font-size:2.2vw;text-align:center;display:none;word-break:break-word;box-shadow:0 2px 8px rgba(0,0,0,0.6);max-width:85vw;backdrop-filter:blur(4px);border:1px solid rgba(255,255,255,0.1);">
  <div id="speech-text" style="font-weight:400;letter-spacing:0.5px;">Listening...</div>
</div>

<div id="button-panel" style="position:fixed;z-index:20;right:3vw;bottom:50%;transform:translateY(50%);display:flex;flex-direction:column;gap:3vw;align-items:center;">
    <button id="zoomInBtn" style="
      background:linear-gradient(135deg,#54de7c,#1e92fa);
      color:#fff;font-size:5.5vw;font-weight:600;
      border:none;border-radius:50%;width:12vw;height:12vw;max-width:56px;max-height:56px;min-width:48px;min-height:48px;
      display:flex;align-items:center;justify-content:center;box-shadow:0 4px 20px rgba(84,222,124,0.4);cursor:pointer;outline:none;touch-action:manipulation;transition:all 0.2s;backdrop-filter:blur(10px);
    " onmouseover="this.style.transform='scale(1.1)';this.style.boxShadow='0 6px 25px rgba(84,222,124,0.6)'" onmouseout="this.style.transform='scale(1)';this.style.boxShadow='0 4px 20px rgba(84,222,124,0.4)'">
      Ôºã
    </button>
    <button id="mic" onclick="startListening()" style="
      background: linear-gradient(135deg,#36d1c4,#5b86e5);
      color: white;
      border: none;
      font-size: 6vw;
      border-radius: 50%;
      width: 16vw;
      height: 16vw;
      max-width: 72px;
      max-height: 72px;
      min-width: 56px;
      min-height: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      cursor: pointer;
      outline: none;
      touch-action: manipulation;
      box-shadow: 0 6px 25px rgba(54,209,196,0.5);
      backdrop-filter: blur(10px);
    " onmouseover="this.style.transform='scale(1.1)';this.style.boxShadow='0 8px 30px rgba(54,209,196,0.7)'" onmouseout="this.style.transform='scale(1)';this.style.boxShadow='0 6px 25px rgba(54,209,196,0.5)'"><span id="mic-emoji">üé§</span></button>
    <button id="zoomOutBtn" style="
      background:linear-gradient(135deg,#fc7e4f,#ff206e);
      color:#fff;font-size:5.5vw;font-weight:600;
      border:none;border-radius:50%;width:12vw;height:12vw;max-width:56px;max-height:56px;min-width:48px;min-height:48px;
      display:flex;align-items:center;justify-content:center;box-shadow:0 4px 20px rgba(252,126,79,0.4);cursor:pointer;outline:none;touch-action:manipulation;transition:all 0.2s;backdrop-filter:blur(10px);
    " onmouseover="this.style.transform='scale(1.1)';this.style.boxShadow='0 6px 25px rgba(252,126,79,0.6)'" onmouseout="this.style.transform='scale(1)';this.style.boxShadow='0 4px 20px rgba(252,126,79,0.4)'">
      Ôºç
    </button>
</div>

<script>
AFRAME.registerComponent('persistent-avatar', {
  init: function () {
    this.placed = false;
    this.marker = this.el.parentEl;
    this.dwellTimeout = null;
    this.dwellTimer = 0;
    this.seen = false;
    const avatar = this.el;
    // Helper: move this entity to world root at given world transform
    this.placeInWorld = (pos, rot, scale) => {
      const scene = avatar.sceneEl;
      // Preserve current visibility state
      const wasVisible = avatar.getAttribute('visible');
      avatar.object3D.position.copy(pos);
      avatar.object3D.rotation.copy(rot);
      if (scale) avatar.object3D.scale.copy(scale);
      scene.appendChild(avatar);
      avatar.setAttribute('persistent', 'true');
      // Keep original visibility state (idle=true, talk=false)
      avatar.setAttribute('visible', wasVisible !== false);
      // Only show label once (from idle entity)
      if (avatar.id === 'idle') {
        showConnectedLabel(pos);
      }
    };
    // Start checking for dwell
    this.dwellTick = () => {
      if (this.placed) return;
      if (this.seen) {
        this.dwellTimer += 0.2;
        if (this.dwellTimer >= 5) {
          // Place and lock avatar
          let worldPos = new THREE.Vector3();
          let worldRot = new THREE.Euler();
          let worldScale = new THREE.Vector3();
          avatar.object3D.getWorldPosition(worldPos);
          avatar.object3D.getWorldQuaternion().toEuler(worldRot);
          avatar.object3D.getWorldScale(worldScale);
          this.placeInWorld(worldPos, worldRot, worldScale);
          if(this.marker) this.marker.setAttribute('visible', 'false');
          this.placed = true;
        }
      } else {
        this.dwellTimer = 0;
      }
      setTimeout(this.dwellTick, 200);
    };
    this.marker.addEventListener('markerFound', () => {
      if (this.placed) return;
      this.seen = true;
    });
    this.marker.addEventListener('markerLost', () => {
      if (!this.placed) this.seen = false;
    });
    this.dwellTick();
  }
});

// Add floating label for 'Avatar Connected!'
function showConnectedLabel(pos3) {
  let scene = document.querySelector('a-scene');
  let label = document.createElement('a-entity');
  label.setAttribute('position', `${pos3.x} ${pos3.y+0.6} ${pos3.z}`);
  label.setAttribute('text', "value:Avatar Connected!; align:center; color:#0fc; width:4");
  label.setAttribute('visible', 'true');
  scene.appendChild(label);
  setTimeout(()=>{scene.removeChild(label);}, 2000);
  
  // Activate avatar and play welcome message
  avatarActive = true;
  enableMicButton();
  playWelcomeMessage();
}

function playWelcomeMessage() {
  const welcomeText = "Hi, I am your augmented reality friend. I can help you with anytime anywhere in your present through the watch.";
  switchToTalk();
  speakAnswer(welcomeText, () => {
    switchToIdle();
  });
}


// Global state
let avatarActive = false;
let currentAnimation = null;
let backgroundMusic = null;

const micBtn = document.getElementById('mic');
const micEmoji = document.getElementById('mic-emoji');
const statusEl = document.getElementById('status');
const aiResponseEl = document.getElementById('ai-response');

// All animation entities
const animations = {
  breathing1: document.getElementById('breathing1'),
  breathing2: document.getElementById('breathing2'),
  talking1: document.getElementById('talking1'),
  talking2: document.getElementById('talking2'),
  dance1: document.getElementById('dance1'),
  dance2: document.getElementById('dance2'),
  dance3: document.getElementById('dance3'),
  fight1: document.getElementById('fight1'),
  fight2: document.getElementById('fight2'),
  happy: document.getElementById('happy'),
  laughing: document.getElementById('laughing'),
  sad: document.getElementById('sad'),
  sitting: document.getElementById('sitting'),
  sing: document.getElementById('sing')
};

// Animation manager
function playAnimation(animName, random = false) {
  // Hide all animations
  Object.keys(animations).forEach(key => {
    const el = animations[key];
    if (el) {
      el.setAttribute('visible', 'false');
      if (el.object3D) el.object3D.visible = false;
    }
  });
  
  // If random, pick between variants
  let finalAnim = animName;
  if (random) {
    if (animName === 'breathing') {
      finalAnim = Math.random() > 0.5 ? 'breathing1' : 'breathing2';
    } else if (animName === 'talking') {
      finalAnim = Math.random() > 0.5 ? 'talking1' : 'talking2';
    } else if (animName === 'dance') {
      const dances = ['dance1', 'dance2', 'dance3'];
      finalAnim = dances[Math.floor(Math.random() * dances.length)];
    } else if (animName === 'fight') {
      finalAnim = Math.random() > 0.5 ? 'fight1' : 'fight2';
    }
  }
  
  // Show selected animation
  const el = animations[finalAnim];
  if (el) {
    el.setAttribute('visible', 'true');
    if (el.object3D) el.object3D.visible = true;
    currentAnimation = finalAnim;
  }
}

function switchToIdle() {
  playAnimation('breathing', true);
}

function switchToTalk() {
  playAnimation('talking', true);
}

function speakWithTalkAnim(text, onEnd) {
  // Ensure we start in idle state
  switchToIdle();
  isSpeaking = false;
  
  const msg = new SpeechSynthesisUtterance(text);
  msg.rate = 0.92;
  msg.pitch = 1.0;
  
  msg.onstart = () => {
    // Only switch to talk animation when speech actually starts
    isSpeaking = true;
    switchToTalk();
  };
  
  msg.onend = () => {
    // Switch back to idle when speech ends
    isSpeaking = false;
    switchToIdle();
    if (onEnd) onEnd();
  };
  
  msg.onerror = () => {
    // If speech fails, stay in idle
    isSpeaking = false;
    switchToIdle();
  };
  
  window.speechSynthesis.cancel(); // Always stop before starting
  window.speechSynthesis.speak(msg);
}

function enableMicButton() {
  micBtn.style.opacity = '1';
  micBtn.style.pointerEvents = 'auto';
  micBtn.disabled = false;
}

function disableMicButton() {
  micBtn.style.opacity = '0.5';
  micBtn.style.pointerEvents = 'none';
  micBtn.disabled = true;
}

function startListening() {
  if (!avatarActive) {
    const speechOverlay = document.getElementById('speech-overlay');
    const speechText = document.getElementById('speech-text');
    speechOverlay.style.display = 'block';
    speechText.innerText = 'Avatar not active yet. Wait for connection.';
    setTimeout(() => {
      speechOverlay.style.display = 'none';
    }, 2000);
    return;
  }
  
  if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
    alert('Sorry! Speech recognition not available.');
    return;
  }
  
  micBtn.classList.add('recording');
  micEmoji.innerText = 'üî¥';
  
  // Show speech overlay
  const speechOverlay = document.getElementById('speech-overlay');
  const speechText = document.getElementById('speech-text');
  speechOverlay.style.display = 'block';
  speechText.innerText = 'Listening...';

  const recog = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
  recog.lang = "en-US";
  recog.interimResults = true;
  recog.continuous = false;
  recog.start();

  recog.onresult = (e) => {
    let interimText = '';
    let finalText = '';
    
    for (let i = e.resultIndex; i < e.results.length; i++) {
      const transcript = e.results[i][0].transcript;
      if (e.results[i].isFinal) {
        finalText += transcript + ' ';
      } else {
        interimText += transcript;
      }
    }
    
    // Show what user is saying in real-time
    if (interimText) {
      speechText.innerText = interimText;
    }
    
    // When user stops speaking, send to AI
    if (finalText) {
      const question = finalText.trim();
      speechText.innerText = 'You: ' + question;
      micEmoji.innerText = '‚è≥';
      micBtn.classList.remove('recording');
      
      // Send to OpenRouter
      setTimeout(() => {
        askAI(question);
      }, 500);
    }
  };
  
  recog.onerror = (e) => {
    speechText.innerText = 'Error. Try again.';
    micEmoji.innerText = 'üé§';
    micBtn.classList.remove('recording');
    setTimeout(() => {
      speechOverlay.style.display = 'none';
    }, 2000);
  };
  
  recog.onend = () => {
    if (micBtn.classList.contains('recording')) {
      micBtn.classList.remove('recording');
      micEmoji.innerText = 'üé§';
    }
  };
}

async function askAI(question) {
  const speechOverlay = document.getElementById('speech-overlay');
  const speechText = document.getElementById('speech-text');
  
  // Show thinking status
  speechOverlay.style.display = 'block';
  speechText.innerText = 'Thinking...';
  
  // Avatar stays in idle while waiting
  switchToIdle();
  
  // Check for direct commands first
  const lowerQuestion = question.toLowerCase();
  
  if (lowerQuestion.includes('dance')) {
    handleDance();
    speechOverlay.style.display = 'none';
    return;
  }
  
  if (lowerQuestion.includes('sit') || lowerQuestion.includes('sit down')) {
    playAnimation('sitting');
    speakAnswer("Okay, I'm sitting down now.");
    speechOverlay.style.display = 'none';
    return;
  }
  
  if (lowerQuestion.includes('stand') || lowerQuestion.includes('stand up')) {
    switchToIdle();
    speakAnswer("I'm standing up now.");
    speechOverlay.style.display = 'none';
    return;
  }
  
  if (lowerQuestion.includes('sing')) {
    handleSing();
    speechOverlay.style.display = 'none';
    return;
  }
  
  try {
    // Send question to local server
    const res = await fetch("http://127.0.0.1:8000/ask", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({question: question})
    });
    
    if (!res.ok) {
      throw new Error(`Server error: ${res.status}`);
    }
    
    const data = await res.json();
    const answer = data.answer || "Sorry, I couldn't get an answer.";
    const emotion = data.emotion || 'neutral';
    const command = data.command || null;
    
    // Hide overlay
    speechOverlay.style.display = 'none';
    
    // Handle special commands or emotions
    if (command === 'not_supported') {
      const msg = "Our AI is feeding by the developer so some of the basic request can work rest of it will be available soon.";
      speakAnswer(msg);
      return;
    }
    
    // Handle emotions
    handleEmotion(emotion);
    
    // Avatar speaks the answer with appropriate animation
    speakAnswer(answer);
    
  } catch (e) {
    console.error('Error:', e);
    speechText.innerText = 'Server not running. Start main.py';
    setTimeout(() => {
      speechOverlay.style.display = 'none';
    }, 3000);
    switchToIdle();
  }
}

function handleDance() {
  // Play background music (replace with your dance music file)
  if (!backgroundMusic) {
    // You can replace this with your own music file
    backgroundMusic = new Audio('dance_music.mp3'); // Add your dance music file
    backgroundMusic.loop = true;
    backgroundMusic.volume = 0.5;
  }
  backgroundMusic.play();
  
  // Play random dance animation
  const dances = ['dance1', 'dance2', 'dance3'];
  const randomDance = dances[Math.floor(Math.random() * dances.length)];
  playAnimation(randomDance);
  
  speakAnswer("Let's dance!", () => {
    // Keep dancing for 10 seconds, then stop
    setTimeout(() => {
      if (backgroundMusic) {
        backgroundMusic.pause();
        backgroundMusic.currentTime = 0;
      }
      switchToIdle();
    }, 10000);
  });
}

function handleSing() {
  playAnimation('sing');
  const song = "La la la, I'm singing a simple song for you. La la la, hope you enjoy it too!";
  speakAnswer(song, () => {
    switchToIdle();
  });
}

function handleEmotion(emotion) {
  // Don't override special animations
  if (['dance1', 'dance2', 'dance3', 'sitting', 'sing'].includes(currentAnimation)) {
    return;
  }
  
  switch(emotion) {
    case 'angry':
      playAnimation('fight', true);
      break;
    case 'happy':
      playAnimation('happy');
      break;
    case 'very_happy':
    case 'extremely_happy':
      playAnimation('laughing');
      break;
    case 'sad':
      playAnimation('sad');
      break;
    default:
      // Will use talking animation in speakAnswer
      break;
  }
}

function speakAnswer(answer, onEnd = null) {
  // Use speech synthesis to speak the answer
  const msg = new SpeechSynthesisUtterance(answer);
  msg.rate = 0.92;
  msg.pitch = 1.0;
  
  // Switch to talk animation when speech starts (unless already in special animation)
  msg.onstart = () => {
    isSpeaking = true;
    // Only switch to talk if not in a special animation
    if (!['dance1', 'dance2', 'dance3', 'sitting', 'sing'].includes(currentAnimation)) {
      switchToTalk();
    }
  };
  
  // Switch back to idle when speech ends (or use callback)
  msg.onend = () => {
    isSpeaking = false;
    if (onEnd) {
      onEnd();
    } else {
      // Only switch to idle if not in a special animation
      if (!['dance1', 'dance2', 'dance3', 'sitting', 'sing'].includes(currentAnimation)) {
        switchToIdle();
      }
    }
  };
  
  msg.onerror = () => {
    isSpeaking = false;
    if (onEnd) {
      onEnd();
    } else {
      switchToIdle();
    }
  };
  
  // Cancel any previous speech and start
  window.speechSynthesis.cancel();
  window.speechSynthesis.speak(msg);
}

// Initialize: ensure idle is visible and mic is disabled
switchToIdle();
disableMicButton();

// Add periodic check to ensure idle is default when not speaking
let isSpeaking = false;
setInterval(() => {
  if (!isSpeaking && window.speechSynthesis && !window.speechSynthesis.speaking) {
    // Only switch to idle if not in a special animation
    if (!['dance1', 'dance2', 'dance3', 'sitting', 'sing'].includes(currentAnimation)) {
      switchToIdle();
    }
  }
}, 500);

// --- Pinch & Rotate gesture support for persistent avatars ---
(function() {
  // Attach events to both idle and talk avatars
  ['idle','talk'].forEach(function(id) {
    let el = document.getElementById(id);
    let startDist = 0, startScale = 1, startRot = 0, baseRot = 0;
    el.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        startDist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        startScale = el.object3D.scale.x;
        startRot = Math.atan2(
          e.touches[1].clientY - e.touches[0].clientY,
          e.touches[1].clientX - e.touches[0].clientX
        );
        baseRot = el.object3D.rotation.y;
      }
    });
    el.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        const curDist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        let scale = Math.max(0.1, Math.min(3, startScale * (curDist / startDist)));
        el.setAttribute('scale', `${scale} ${scale} ${scale}`);
        const curRot = Math.atan2(
          e.touches[1].clientY - e.touches[0].clientY,
          e.touches[1].clientX - e.touches[0].clientX
        );
        let deltaRot = curRot - startRot;
        if (deltaRot > Math.PI) deltaRot -= 2 * Math.PI;
        if (deltaRot < -Math.PI) deltaRot += 2 * Math.PI;
        el.object3D.rotation.y = baseRot + deltaRot;
      }
    });
  });
})();
// Zoom in / out button functionality
(function() {
  function adjustScale(factor) {
    ['idle','talk'].forEach(function(id) {
      let el = document.getElementById(id);
      let scaleVec = el.object3D.scale;
      let newScale = Math.max(0.1, Math.min(3, scaleVec.x * factor));
      el.object3D.scale.set(newScale, newScale, newScale);
      el.setAttribute('scale', `${newScale} ${newScale} ${newScale}`);
    });
  }
  document.getElementById('zoomInBtn').onclick = function(e) { adjustScale(1.15); }
  document.getElementById('zoomOutBtn').onclick = function(e) { adjustScale(0.85); }
})();
</script>
</body>
</html>

